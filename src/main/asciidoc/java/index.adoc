= Vertx unit

Asynchronous polyglot unit testing.

== Introduction

Vertx Unit aims to make Vertx applications testable. It provides a polyglot API for writing asynchronous
tests easily. Vertx Unit Api borrows from existing test frameworks like http://junit.org[JUnit] or http://qunitjs.com[QUnit]
and follows the Vert.x practices.

Vertx Unit can be used in different ways and run anywhere your code runs, it is just a matter of reporting
the results the right way, this example shows the bare minimum test suite:

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case", test -> {
  String s = "value";
  test.assertEquals("value", s);
});
suite.run();
----

The  method will execute the suite and go through all the
tests of the suite. The suite can fail or pass, this does not matter if the outter world is not aware
of the test result.

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case", test -> {
  String s = "value";
  test.assertEquals("value", s);
});
suite.run(new TestOptions().addReporter(new ReportOptions().setTo("console")));
----

When executed, the test suite now reports to the console the steps of the test suite:

----
Begin test suite the_test_suite
Begin test my_test
Passed my_test
End test suite the_test_suite , run: 1, Failures: 0, Errors: 0
----

The  option configures the reporters used by the suite runner for reporting the execution
of the tests, see the <<reporting>> section for more info.

== Writing a test suite

A test suite is a named collection of test case, a test case is a straight callback to execute. The suite can
have lifecycle callbacks to execute _before_ and/or _after_ the test cases or the test suite that are used for
initializing or disposing services used by the test suite.

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case_1", test -> {
  // Test 1
});
suite.test("my_test_case_2", test -> {
  // Test 2
});
suite.test("my_test_case_3", test -> {
  // Test 3
});
----

The API is fluent and therefore the test can be chained:

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case_1", test -> {
  // Test 1
}).test("my_test_case_2", test -> {
  // Test 2
}).test("my_test_case_3", test -> {
  // Test 3
});
----

Vertx Unit provides _before_ and _after_ callbacks for doing global setup or cleanup:

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.before(test -> {
  // Test suite setup
}).test("my_test_case_1", test -> {
  // Test 1
}).test("my_test_case_2", test -> {
  // Test 2
}).test("my_test_case_3", test -> {
  // Test 3
}).after(test -> {
  // Test suite cleanup
});
----

The declaration order of the method does not matter, the example declares the _before_ callback before
the test cases and _after_ callback after the test cases but it could be anywhere, as long as it is done before
running the test suite.

The _before_ callback is executed before any tests, when it fails, the test suite execution will stop and the
failure is reported. The _after_ callback is the last callback executed by the testsuite, unless
the _before_ callback reporter a failure.

Likewise, Vertx Unit provides the _beforeEach_ and _afterEach_ callback that do the same but are executed
for each test case:

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.beforeEach(test -> {
  // Test case setup
}).test("my_test_case_1", test -> {
  // Test 1
}).test("my_test_case_2", test -> {
  // Test 2
}).test("my_test_case_3", test -> {
  // Test 3
}).afterEach(test -> {
  // Test case cleanup
});
----

The _beforeEach_ callback is executed before each test case, when it fails, the test case is not executed and the
failure is reported. The _afterEach_ callback is the executed just after the test case callback, unless
the _beforeEach_ callback reported a failure.

== Asserting

Vertx Unit provides the _test_ object for doing assertions in test cases. The _test_ object provides the usual
methods when dealing with assertions.

=== assertEquals

Assert two objects are equals, works for _basic_ types or _json_ types.

[source,java]
----
suite.test("my_test_case", test -> {
  test.assertEquals(10, callbackCount);
});
----

There is also an overloaded version for providing a message:

[source,java]
----
suite.test("my_test_case", test -> {
  test.assertEquals(10, callbackCount, "Should have been 10 instead of " + callbackCount);
});
----

Usually each assertion provides an overloaded version.

=== assertNotEquals

The counter part of _assertEquals_.

[source,java]
----
suite.test("my_test_case", test -> {
  test.assertNotEquals(10, callbackCount);
});
----

=== assertTrue and assertFalse

Asserts the value of a boolean expression.

[source,java]
----
suite.test("my_test_case", test -> {
  test.assertTrue(var);
  test.assertFalse(value > 10);
});
----

=== Failing

Last but not least, _test_ provides a _fail_ method that will throw an assertion error:

[source,java]
----
suite.test("my_test_case", test -> {
  test.fail("That should never happen");
  // Following statements won't be executed
});
----

== Asynchronous testing

The previous examples supposed that test cases were terminated after their respective callbacks, this is the
default behavior of a test case callback. Often it is desirable to terminate the test after the test case
callback, for instance:

.The Async object asynchronously completes the test case
[source,java]
----
suite.test("my_test_case", test -> {
  Async async = test.async();
  eventBus.consumer("the-address", msg -> {
    // <2>
    async.complete();
  });
  // <1>
});
----
<1> The callback exits but the test case is not terminated
<2> The event callback from the bus terminates the test

Creating an `link:apidocs/io/vertx/ext/unit/Async.html[Async]` object with the `link:apidocs/io/vertx/ext/unit/Test.html#async--[async]` method marks the
executed test case as non terminated. The test case terminates when the `link:apidocs/io/vertx/ext/unit/Async.html#complete--[complete]`
method is invoked.

NOTE: When the `complete` callback is not invoked, the test case fails after a certain timeout.

Several `Async` objects can be created during the same test case, all of them must be _completed_ to terminate
the test.

.Several Async objects provide coordination
[source,java]
----
suite.test("my_test_case", test -> {

  Async async1 = test.async();
  HttpClient client = vertx.createHttpClient();
  HttpClientRequest req = client.get(8080, "localhost", "/");
  req.exceptionHandler(err -> test.fail(err.getMessage()));
  req.handler(resp -> {
    test.assertEquals(200, resp.statusCode());
    async1.complete();
  });
  req.end();

  Async async2 = test.async();
  vertx.eventBus().consumer("the-address", msg -> {
    async2.complete();
  });
});
----

Async objects can also be used in _before_ or _after_ callbacks, it can be very convenient in a _before_ callback
to implement a setup that depends on one or several asynchronous results:

.Async start an http server before test cases
[source,java]
----
suite.before(test -> {
  Async async = test.async();
  HttpServer server = vertx.createHttpServer();
  server.requestHandler(requestHandler);
  server.listen(8080, ar -> {
    test.assertTrue(ar.succeeded());
    async.complete();
  });
});
----

[[reporting]]
== Running

When a test suite is created, it won't be executed until the `link:apidocs/io/vertx/ext/unit/TestSuite.html#run--[run]` method
is called.

.Running a test suite
[source,java]
----
suite.run();
----

When the testsuite is executed, it will use the current Vert.x event loop for the steps of the test suite,
that is the context object returned by `io.vertx.core.Vertx#currentContext`. When such context does not
exist, the test suite is executed synchronously in the current thread.

The test suite can also be ran with a specified `Vertx` instance:

.Provides a Vertx instance to run the test suite
[source,java]
----
suite.run(vertx);
----

This execution uses the `Context` provided by the `Vertx` instance for runnings the steps of the test suite.

=== Test suite completion

No assumptions can be made about when the test suite will be completed, and if some code needs to be executed
after the test suite, it should either be in the test suite _after_ callback or as callback of the
`link:apidocs/io/vertx/ext/unit/TestCompletion.html[TestCompletion]`:

.Test suite execution callback
[source,java]
----
TestCompletion completion = suite.run(vertx);
completion.handler(ar -> {
  if (ar.succeeded()) {
    System.out.println("Test suite passed!");
  } else {
    System.out.println("Test suite failed:");
    ar.cause().printStackTrace();
  }
});
----

The `TestCompletion` object provides also a `link:apidocs/io/vertx/ext/unit/TestCompletion.html#resolve-io.vertx.core.Future-[resolve]` method that
takes a `Future` object, this `Future` will be notified of the test suite execution:

.Resolving the start Future with the test suite
[source,java]
----
TestSuite suite = TestSuite.create("my_test_suite");
suite.test("my_test_case", test -> {
  // Do something
});
suite.run().resolve(startFuture);
----

This allow to easily create a _test_ verticle whose deployment is the test suite execution, allowing the
code that deploys it to be easily aware of the success or failure.

=== Time out

The test cases of a test suite must execute before a certain timeout is reached. The default timeout is
of _2 minutes_, it can be changed using _test options_:

.Setting the test suite timeout
[source,java]
----
TestOptions options = new TestOptions().setTimeout(10000);

// Run with a 10 seconds time out
suite.run(options);
----

== Reporting

Reporting is an important piece of a test suite, Vertx Unit can be configured to run with different kind
of reporters.

By default no reporter is configured, when running a test suite, _test options_ can be provided to
configure one or several:

.Using the console reporter and as a junit xml file
[source,java]
----
suite.run(new TestOptions().
        addReporter(new ReportOptions().
            setTo("console")).
        addReporter(new ReportOptions().
            setTo("file").
            setAt("report.xml").
            setFormat("junit"))
);
----

=== Console reporting

Reports to the JVM `System.out` and `System.err`:

to::
_console_
format::
_simple_ or _junit_

=== File reporting

Reports to a file, a `Vertx` instance must be provided:

to::
_file_
at::
the file name
format::
_simple_ or _junit_

=== Log reporting

Reports to a logger, a `Vertx` instance must be provided:

to::
_log_
at::
the logger name

=== Event bus reporting

Reports events to the event bus, a `Vertx` instance must be provided:

to::
_bus_
at::
the event bus address to which events will be sent

It allow to decouple the execution of the test suite from the reporting.

The messages sent over the event bus can be collected by the `link:apidocs/io/vertx/ext/unit/collect/EventBusCollector.html[EventBusCollector]`
and achieve custom reporting:

[source,java]
----
EventBusCollector collector = EventBusCollector.create(
    vertx,
    new ReportingOptions().addReporter(
        new ReportOptions().setTo("file").setAt("report.xml").setFormat("junit")));

collector.register("the-address");
----

== Junit integration

Although Vertx Unit is polyglot and not based on JUnit, it is possible to run a Vertx Unit test suite or a test case
from JUnit, allowing you to integrate your tests with JUnit and your build system or IDE.

.Run the test suite as a JUnit test suite
[source,java]
----
RunWith(AllTests.class)
public class JUnitTestSuite {

public static TestSuite suite() {
  return io.vertx.ext.unit.TestSuite.create("my_suite").
    test("my_test_case", test -> {
      test.assertTrue(true);
    }).
    test("my_test", test -> {
      // Test 2
    }).toJUnitSuite();
  }
}
----

A single test case can also be executed with a `link:apidocs/io/vertx/ext/unit/TestCase.html[TestCase]`:

.Run a test case in a JUnit test
[source,java]
----
TestCase.
  create("my_test_case", test -> {
    test.assertTrue(true);
  }).
  assertSuccess(); // <1>
----
<1> Block until the test case is executed